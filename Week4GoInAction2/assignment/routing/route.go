package routing

import (
	"html/template"
	"io"
	"log"
	"net/http"
	"os"
	"strconv"
	"time"

	system "Assignment4/booking"

	mux "github.com/gorilla/mux"
	"github.com/joho/godotenv"
	uuid "github.com/satori/go.uuid"
	"golang.org/x/crypto/bcrypt"
)

//userInfo contains information regarding a user.
type userInfo struct {
	Username  string
	Password  []byte
	FirstName string
	LastName  string
}

//result contains fields used to set values in the respective .gohtml files.
type result struct {
	User                userInfo
	DoctorsAvailability template.HTML
	DoctorAvailability  template.HTML
	BookingStatus       bool
	PatientsName        template.HTML
	PatientHistory      template.HTML
	DoctorsName         template.HTML
	DoctorAppointments  template.HTML
	DoctorName          template.HTML
	PatientName         template.HTML
}

//Server uses these variables to store data
//and perform logging actions.
var (
	doctors     system.Doctors
	patients    system.Patients
	mapUsers    = map[string]userInfo{}
	mapSessions = map[string]string{}
	tpl         *template.Template
	r           result
	file        *os.File

	InfoLogger *log.Logger
	WarnLogger *log.Logger
	ErrLogger  *log.Logger
)

//init will only be called once.
func init() {
	//initialize log-related functions
	currentDate := time.Now()
	filename := "logs/" + currentDate.Format("2006-01-02") + "_app.log"
	file, err := os.OpenFile(filename, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
	if err != nil {
		log.Fatalln("Failed to open error log file:", err)
	}

	InfoLogger = log.New(io.MultiWriter(file, os.Stdout), "INFO: ", log.Ldate|log.Ltime|log.Lshortfile)
	WarnLogger = log.New(io.MultiWriter(file, os.Stdout), "WARN: ", log.Ldate|log.Ltime|log.Lshortfile)
	ErrLogger = log.New(io.MultiWriter(file, os.Stdout), "ERROR: ", log.Ldate|log.Ltime|log.Lshortfile)

	//initialize list of doctors
	doctors = system.CreateDoctors()
	patients = system.CreatePatients()
	docList := []string{"ALAN CHEUNG", "ANG BENG CHONG", "CHUA YI YOU", "KARLSSON BENGT GUNNAR", "FOO REN HAO"}
	//InitDoctors only returns an error for empty slice passed to it, so we can safely ignore the error
	_ = doctors.InitDoctors(docList)
	InfoLogger.Println("Initialized list of doctors")

	//initialize admin credentials
	dotErr := godotenv.Load()
	if dotErr != nil {
		ErrLogger.Println("Error loading .env file")
	}

	user := os.Getenv("USER")
	ps := os.Getenv("PS")
	first := os.Getenv("FIRST")
	last := os.Getenv("LAST")
	bps, _ := bcrypt.GenerateFromPassword([]byte(ps), bcrypt.DefaultCost)
	mapUsers["admin"] = userInfo{user, bps, first, last}

	//loads .gohtml templates
	tpl = template.Must(template.ParseGlob("templates/*"))
}

//Route starts a web server at http://127.0.0.1/(port number) or localhost:port
//with a self-signed certificate.
//Logs generated by route are placed in the "logs" directory.
func Route(port int) {
	defer file.Close()

	router := mux.NewRouter()

	addr := "localhost:" + strconv.Itoa(port)

	router.HandleFunc("/", index)
	router.HandleFunc("/admin", admin)
	router.HandleFunc("/home", user)
	router.HandleFunc("/signup", signup)
	router.HandleFunc("/login", login)
	router.HandleFunc("/logout", logout)
	router.HandleFunc("/booking", bookNewAppointment)
	router.HandleFunc("/searchAvailableDoctors", searchAvailableDoctors)
	router.HandleFunc("/searchDoctorAvailability", searchDoctorAvailability)
	router.HandleFunc("/viewDoctorAppointments", viewDoctorAppointments)
	router.HandleFunc("/choosePatient", choosePatient)
	router.HandleFunc("/chooseDoctor", chooseDoctor)
	router.HandleFunc("/viewPatientAppointmentHistory", viewPatientAppointmentHistory)
	router.HandleFunc("/searchAppointment", searchAppointment)
	router.HandleFunc("/editAppointment", editAppointment)
	router.Handle("/favicon.ico", http.NotFoundHandler())

	//log.Fatal(http.ListenAndServe(addr, router))
	//cert path is relative to project home directory.
	err := http.ListenAndServeTLS(addr, "./TLSCerts/cert.pem", "./TLSCerts/key.pem", router)
	if err != nil {
		ErrLogger.Println(err)
		ErrLogger.Fatal("Failed to start the application")
	}

	file.Sync()
}

//Helper Functions

//isLoggedIn checks if a user is logged in based on the username retrieved from loginCookie.
func isLoggedIn(req *http.Request) bool {
	loginCookie, err := req.Cookie("loginCookie")
	if err != nil {
		return false
	}
	username := mapSessions[loginCookie.Value]
	_, ok := mapUsers[username]
	return ok
}

//getUser retrieves the user information if the user is logged in.
func getUser(res http.ResponseWriter, req *http.Request) userInfo {
	// get current session cookie
	loginCookie, err := req.Cookie("loginCookie")
	if err != nil {
		id := uuid.NewV4()
		var expireCookie = time.Now().Add(1 * time.Hour)
		loginCookie = &http.Cookie{
			Name:     "loginCookie",
			Value:    id.String(),
			Expires:  expireCookie,
			Domain:   "localhost",
			Path:     "/",
			Secure:   true,
			HttpOnly: true,
		}

	}
	http.SetCookie(res, loginCookie)

	// if the user exists already, get user
	var myUser userInfo
	if username, ok := mapSessions[loginCookie.Value]; ok {
		myUser = mapUsers[username]
	}

	return myUser
}

//isAdmin checks if the logged-in user is an admin.
func isAdmin(res http.ResponseWriter, req *http.Request) bool {
	myUser := getUser(res, req)
	return myUser.Username == "admin"
}
